-- 1. Tipos Enumerados para Notificaciones
-- Usamos enums para asegurar la consistencia de los datos.

CREATE TYPE public.notification_type AS ENUM (
    'faltante_creado',
    'faltante_actualizado',
    'faltante_estado_cambiado',
    'rechazo_creado',
    'rechazo_actualizado',
    'rechazo_estado_cambiado'
);

CREATE TYPE public.notification_entity_type AS ENUM (
    'faltante',
    'rechazo'
);

-- 2. Tabla `notifications`
-- Almacena el contenido de cada notificación generada en el sistema.

CREATE TABLE public.notifications (
    id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    type public.notification_type NOT NULL,
    title text NOT NULL,
    body text,
    entity_type public.notification_entity_type NOT NULL,
    entity_id bigint NOT NULL, -- ID de la fila en la tabla faltantes/rechazos
    ticket_id text, -- ID legible del ticket (ej. SHP000000123)
    nombre_local text,
    delivery_note text,
    olpn text,
    tipo_reporte text,
    created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,
    created_by_user_id uuid REFERENCES auth.users(id),
    created_by_user_name text,
    dedup_key text NOT NULL UNIQUE
);

COMMENT ON TABLE public.notifications IS 'Contiene cada evento de notificación global del sistema.';
COMMENT ON COLUMN public.notifications.entity_id IS 'ID de la fila en la tabla faltantes o rechazos';
COMMENT ON COLUMN public.notifications.ticket_id IS 'ID legible del ticket (ej. SHP000000123)';
COMMENT ON COLUMN public.notifications.dedup_key IS 'Clave única para prevenir notificaciones duplicadas por el mismo evento.';

-- 3. Tabla `notification_reads`
-- Registra el estado de cada notificación para cada usuario (leída, no leída, eliminada).

CREATE TABLE public.notification_reads (
    notification_id bigint REFERENCES public.notifications(id) ON DELETE CASCADE NOT NULL,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL,
    read_at timestamp with time zone,
    deleted_at timestamp with time zone,
    PRIMARY KEY (notification_id, user_id)
);

COMMENT ON TABLE public.notification_reads IS 'Tabla de unión para el estado de las notificaciones por usuario.';
COMMENT ON COLUMN public.notification_reads.read_at IS 'Timestamp de cuando el usuario marcó la notificación como leída.';
COMMENT ON COLUMN public.notification_reads.deleted_at IS 'Timestamp para soft-delete (eliminado solo para este usuario).';

-- 4. Índices para optimizar consultas
-- Mejoran el rendimiento al buscar y ordenar notificaciones.

CREATE INDEX ON public.notifications (created_at DESC);
CREATE INDEX ON public.notifications (type);
CREATE INDEX ON public.notifications (nombre_local);
CREATE INDEX ON public.notification_reads (user_id, deleted_at, read_at);

-- 5. Habilitar Row Level Security (RLS)
-- Es una buena práctica de seguridad habilitar RLS desde el principio.

ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notification_reads ENABLE ROW LEVEL SECURITY;

-- 6. Políticas de RLS
-- Definen quién puede ver y modificar qué datos.

-- Política para `notifications`: Un usuario puede ver una notificación si existe una entrada para él en `notification_reads`.
CREATE POLICY "Los usuarios pueden ver las notificaciones que les pertenecen"
ON public.notifications FOR SELECT
USING (
  EXISTS (
    SELECT 1
    FROM public.notification_reads
    WHERE notification_reads.notification_id = notifications.id
      AND notification_reads.user_id = auth.uid()
  )
);

-- Política para `notification_reads`: Un usuario solo puede interactuar con sus propios registros de estado.
CREATE POLICY "Los usuarios pueden gestionar el estado de sus propias notificaciones"
ON public.notification_reads FOR ALL
USING (auth.uid() = user_id)
WITH CHECK (auth.uid() = user_id);

-- 7. Habilitar notificaciones en tiempo real para las nuevas tablas
-- Esto permite que Supabase Realtime detecte cambios.
ALTER PUBLICATION supabase_realtime ADD TABLE public.notifications;
ALTER PUBLICATION supabase_realtime ADD TABLE public.notification_reads;
